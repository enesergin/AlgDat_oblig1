[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-f059dc9a6f8d3a56e377f745f24479a46679e63a5d9fe6f495e02850cd0d8118.svg)](https://classroom.github.com/online_ide?assignment_repo_id=453432&assignment_repo_type=GroupAssignmentRepo)
# Obligatorisk oppgave 1 i Algoritmer og Datastrukturer

Denne oppgaven er en innlevering i Algoritmer og Datastrukturer. 
Oppgaven er levert av følgende studenter:
* Enes Ergin, s351880, s351880@oslomet.no
# Notat til den som retter
Dersom det er Andre som retter, du vet om problemene jeg har opplevd og hvorfor arbeidet ikke er godt spredt utover tid og hvorfor git-bruket ikke er det beste. Dersom det er noen andre som retter, Andre har sagt at det er greit for å få godkjent, men at jeg må være ekstra flink med dokumentasjon på readme-filen. Det skal jeg gjøre mitt beste på :)


# Oppgavebeskrivelse

I oppgave 1 så fulgte jeg oppskriften som er gitt i oppgaveteksten. Starter maks metoden med å sjekke om tabellen som er gitt inn har 0 i lengde og da kastes det en noSuchElementException. Deretter har jeg en løkke som holder styr på hvilket element i tabellen vi er på, og kan bruke det elementet til å sammenligne med elementet som har 1 høyere i index. Dersom verdien vi er på er høyere enn neste verdi, skal disse to elementene bytte plass slik at den største av de to verdiene flytter seg til høyre i arrayet. Til slutt vil det siste elementet i arrayet være det største tallet.

- Det vil bli flest ombyttinger når første verdien er den største verdien i tabellen. Da vil det skje en ombytting for hver gang vi går gjennom løkken.

- Det vil være færrest ombyttinger når arrayet som er sendt inn er sortert stigende. Da vil det ikke være et eneste lement som er høyere enn neste element i arrayet, og det vil skje null ombyttinger gjennom hele arrayet.

- Når det gjelder dette spørsmålet må jeg være ærlig og si at jeg ikke helt har forstått spørsmålet. Når det er snakk om gjenommsnittet så er jeg ikke sikker på om det er snakk om 100 tall eller om det er snakk om 5 tall. Jeg hadde selvfølgelig spurt noen om hjelp, men som forklart på starten, jeg har hatt litt mange personlige hindringer og jeg har ikke fått muligheten til å få hjelp.

I oppgave 2 starter jeg med å sjekke om arrayet har lengde 0 eller ikke. Dersom det har 0 i lengde, returner jeg 0 fordi den har ingen ulike verdier. Etter å ha sjekket om det har null verdier, sjekker jeg om det er sortert i stigende rekkefølge. Hvis det ikke er sortert i stigende rekkefølge, kaster jeg en IllegalStateException med passende tekst. Deretter kjører jeg en loop som looper gjennom alle elementene i arrayet. Hver gang vi går inn i loopen setter jeg en boolean unik til å være true, og jeg kjører en loop til som sjekker alle elementene til høyre for det elementet i den første loopen. Dersom verdien til elementet i den første loopen er lik noen av tallene til høyre for den i arrayet vil den ikke være unik, og det plusses ikke i telleren. Dersom vi f.ek.s har arrayet {3,3,3,5,6,7,8} vil ikke verdien 3 være unik de to første gangene, men den vil være unik den tredje gangen fordi vi ikke finner samme verdi til høyre for den. Dersom arrayet f.eks. bare innheholder én 5, vil den være unik fra start fordi vi ikke finner et element med samme verdi til høyre for den.

I oppgave 3 har jeg ganske lik løsning som oppgave 2. Koden starter med å sjekke om arrayet har lengde 0 eller ikke. Dersom det har 0 i lengde, returner jeg 0 fordi den har ingen ulike verdier. Deretter kjører jeg en loop som looper gjennom alle elementene i arrayet. Hver gang vi går inn i loopen setter jeg en boolean unik til å være true. Deretter kjører jeg en loop til, inni den første loopen, som sjekker alle tallene til venstre for det elementet vi er på i den første loopen. Dersom den indre loopen finner et element til venstre for det tallet i den første loopen som er helt lik, vil ikke det tallet være unikt og det plusses ikke på telleren. F.eks. hvis vi har arrayet {8,8,4,2,9,7,4,2,3} vil 8 være unik første gang fordi det ikke er en annen 8 til venstre for den, men andre gangen i den første loopen vil ikke 8 være unik fordi det ligger en annen 8 til venstre for den. Det samme gjelder tallet 2 og 4 i eksempel arrayet. De vil være unike første gangen vi finner dem i arrayet (loopen starter fra venstre), men andre gangen vil de ikke lenger være unike fordi et element med samme verdi finnes på venstre siden dens

I oppgave 4 møtte jeg på noen problemer. Jeg har klart å skrive effektiv kode som bare failer testen med negative verdier, og jeg har klart å skrive kode som bare failer testen for tid. Jeg har også klart å finne kode som passerer alle testene, men jeg har ikke lyst til å bruke kode som jeg ikke har helt forstått. Koden som ligger inne nå passerer ikke testen for tid, og jeg har sett hintet som er skrevet, men jeg har ikke hatt tid til å lære meg en partisjonsteknikk kode som jeg forstår 100%. Koden starter med å definere et variabel for oddetall som blir fulgt opp av en for-løkke som går gjennom hele arrayet, og finner ut hvor mange oddetall det er. Dette skal senere brukes til å sortere oddetall og partall hver for seg. Deretter har jeg en dobbel for-løkke hvor den ytre løkken starter fra det første elementet i arrayet, og den indre løkken starter fra elementet til høyre for det første elementet i arrayet, altså det andre elementet. Inne i den indre løkken har jeg en if-betingelse som finner ut om tallet til høyre er oddetall når tallet til venstre er partall. Dersom dette er sant, skal disse to verdiene bytte plass slik at alle oddetallene er på venstre side for arrayet. Til slutt bruker vi oddetall-telleren til å sortere alle oddetallene og partallene hver for seg.

I oppgave 5 starter jeg metoden med å sjekke om arrayet har lengden 2 eller lengre. Dersom arrayet har lengde 0 eller 1, vil ikke en rotasjon gjøre noe. Derettet lagrer jeg siste-verdi av arrayet (som skal "roteres" til index 0) ved hjelp av en hjelpevariabel. Så kjører jeg en loop som starter fra nest siste index i arrayet og subtraherer med 1 for hver runde i loopen, og flytter elementet i hver loop en plass til høyre. På denne måten mister vi siste verdi av arrayet, men bruker derfor hjelpevariabelen til å definere index 0 til å være elementet som opprinnelig var på siste index.

I oppgave 7a starter jeg metoden med å definere en ny StringBuilder som vi skal bruke for utskriften av den nye stringen vi bygger fra de to Stringene vi får inn. Deretter har vi tre betingelser for tre forskjellige muligheter. Dette er da at String s er lengre enn String t, at String t er lengre enn String s eller at de er like lange. Hvilken betingelse vi går inn i er bestemt av lengdene av Stringene vi får inn, og alle tre betingelsene gjør stort sett det samme. De kjører en loop som tar en og en bokstav fra hver String og setter det inn i den nye Stringen vi bygger. Loopen starter på 0 for første bokstav og slutter på den lengste av de to Stringene vi har fått inn. I det ene tilfellet er som sagt Stringene som er gitt inn like lange, og i dette tilfellet er koden ferdig nå og vi returnerer den nye Stringen. I de to andre tilfellene kjører vi en loop til for der vi slapp av i forrige loop, og setter inn en og en bokstav inn i den nye Stringen helt til slutten av den lengste Stringen som ble gitt inn. Etter at alle bokstavene til begge Stringer er satt inn i den nye Stringen, returnerer vi den nye Stringen.

I oppgave 7b starter jeg metoden på samme måte som 7a, altså ved å definere StringBuilder. Deretter kjører jeg en loop for å finne ut hvilken av Stringene som har blitt sendt inn er lengst, og lagrer denne verdien med en hjelpevariabel som er kalt lengste_string. Så kjører jeg enda en for loop som holder styr på bokstav indexen vår. Loopen starter fra 0 og slutter på lengden av den lengste Stringen. Dvs. f.eks. når i = 4 vil vi ta 4. bokstav fra hver String. Inne i bokstav loopen har jeg en loop til som looper gjennom Stringene som ble sendt inn. Inne i String loopen har jeg en betingelse som spør om Stringen er lengre enn bokstav indexen vi er på. Dersom indexen til den første loopen, altså bokstav indexen, er lengre enn lengden til Stringen vi er på i den andre loopen, betyr det at vi allerede har gått gjennom alle bokstavene til Stringen, og den går ikke inn i if-betingelsen. Altså hvis bokstav index i = 5, og den andre loopen er på en String r som har lengde 3, da kan man ikke ta 5. bokstav fra String r fordi den er ikke lang nok.